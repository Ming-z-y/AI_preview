#### 搜索求解

复习：

* 状态空间法举例
  * N * N 阶数码问题
  * 练习题：画8数码的状态空间图

![image-20230619234921107](C:\Users\hp   Ming\AppData\Roaming\Typora\typora-user-images\image-20230619234921107.png)

* 与或图

##### 搜索策略

* OPEN表和CLOSE表
  * OPEN表存放待搜索来扩展节点
  * CLOSE表存放已搜索的已拓展节点

##### 搜索算法框架

* 建立一个只含有起始节点S的搜索图G，把S放到一个叫做OPEN的未拓展节点表中
* 建立一个叫做CLOSED的已拓展节点表，其初始为空表。
* LOOP：若OPEN为空表，则失败退出
* 选择OPEN表上的第一个节点，把它从OPEN表移出并放入CLOSED表中。称此节点为节点n。
* 若n为目标节点，则有解并成功退出，此解是追踪图G中沿着指针从n到S这条路径而得到的。
* 拓展节点n，同时生成不是n的祖先的哪些后继节点的集合M。把M的这些成员作为n的后继节点添入图G中。

搜索过程中的第八步对OPEN表上的节点进行排序，一遍能够从中选出一个 ”最好“ 的节点作为第4步拓展用。这种排序可以是盲目的 (属于无信息搜索)，也可以用以后要讨论的各种启发思想或其它准则为依据（属于启发式搜索）。每当被选作拓展的节点为目标节点时，这一过程就宣告结束。这时，能够重现从起始节点到目标节点的这条成功路径，其办法是从目标节点按指针向S进行回溯。

##### 无信息搜索

* 宽度优先搜索
* 深度优先搜索

##### 宽度优先搜索

* 唯一的区别：把n的所有后继节点放到OPEN队列的末端，并提供从这些后继节点回到n的指针。

##### 例子：

![image-20230620001419347](C:\Users\hp   Ming\AppData\Roaming\Typora\typora-user-images\image-20230620001419347.png)

宽度优先搜索：搜索是以接近起始节点的程度依次拓展节点。

宽度优先搜索的特点：

* 无信息搜索（一种蛮力搜索算法）
* OPEN表为 ”先进先出“ 的队列实现
* 能够找到一条通向目标的最短路径
* 搜索树提供了所有可能的路径

##### 深度优先搜索

步骤不同的地方：

* 拓展n节点，将其所有子节点配上返回n的指针，并按次序压入OPEN堆栈。

##### 特点

* OPEN作为一种 “后进先出” 的栈进行操作，最新节点先展开
* 许多应用问题，搜索树可能无线深或超出搜索路径深度上限

##### 有界深度优先搜索

引入搜索深度限制值d，使深度优先搜索过程具有完备性。沿着一条路径搜索下去直到深度界限回溯到上一个节点。

步骤新增了一步：

* 判断n的深度如果 d(n) = n, 则继续从OPNE表取节点，而不将n后继节点也加入OPEN中
* 根节点深度为0

##### 等代价搜索

宽度优先搜索可以被推广解决寻找从起始位置状态至目标状态具有最小代价的路径问题，这种推广了的宽度优先搜索算法叫做等代价搜索算法。

ppt上给的步骤很懵，自己翻阅别人的博客然后自己的总结：

步骤：

* 起始节点记为S，将S点加入OPEN表中，g(S) = 0;
* 取出OPEN中g最小的节点，将其放入CLOSED表中；
* 将S的后继节点(但是没有被加入CLOSED表中的点) 加入OPEN表中，并且计算出对应的g，g(j) = g(i) + c(i, j)；
* 重复2，3步骤，直到在OPEN表中取出g最小的节点为目标节点

##### 启发式搜索（有信息搜索）

ps：前面讲的搜索（好像等待加搜索是有信息搜索）都是无信息搜索，或者说是暴力搜索，时间和空间复杂度都是很高的，但是有的时候我们可以利用已有的信息对搜索树进行剪枝，或者是每次加入节点中都加入最有希望的节点，避免盲目进行拓展，这个时候就可以很有效的进行搜索。

##### 启发式搜索策略

* 选择最有希望的节点来确定要拓展的下一个节点，避免盲目拓展
* 在拓展一个节点的过程中，用于确定要生成哪一个或者哪几个后继节点，避免盲目生成所有可能节点
* 用于确定某些应该从搜索书中抛弃或修剪的节点

但是我们如何来判断哪一个节点是否值得我们优先选择呢？

我们可以用数学表达的方式，定量对每个节点都要计算一个信息，比较信息的大小然后选择拓展的节点就行了。

这里我们引入两个函数：

* 评价函数：估算节点 “希望” 的量度。通常用 f(n) 来表示节点n的估价函数值
* 启发函数h(n)：从节点n到某目标节点的一条最佳路径的预期代价，依赖于有关问题的领域的启发信息

建立估价函数的一般方法：

* 试图确定一个处在最佳路径上的节点的概率；
* 提出任意节点与目标集之间的距离量度或差别量度
* 在棋盘式的博弈和难题中根据棋局的某些特点来决定棋局的得分数

##### 引入问题：寻找从城市A到城市K之间最短路径

设置评价函数和启发函数：

![image-20230620092317196](C:\Users\hp   Ming\AppData\Roaming\Typora\typora-user-images\image-20230620092317196.png)



##### 有序搜索

用评价函数 f(n) 来对图搜索策略循环最后步骤排列OPEN表上的节点。应用某个算法（例如等代价算法）选择OPEN表上最有最小 f 值的节点作为下一个要扩展的节点。这种搜索方法叫做有序搜索或最佳优先搜索，而其算法就叫做有序搜索算法或最佳优先算法

步骤：

* 把起始节点S放到OPEN表中，计算 f(s) 并把其值与节点 S 联系起来
* 如果OPEN是一个空表，就退出
* 从OPEN表中选择一个f值最小的节点i，结果有几个节点合格，当其中一个为目标节点时，则选择次目标节点，否则就选择其中任意一个节点作为节点i
* 将i从OPEN表移到CLOSED表中
* 如果i时目标节点，则退出获得一个解
* 拓展节点i，生成其后的全部后继节点，对于i的每一个后继节点j；
  * 计算f(j)
  * 如果j既不在OPEN表中又不在CLOSED表中，则使用评价函数f将其添入OPEN表中。使j指向父辈节点i的指针
  * 如果j在OPEN表上或CLOSED表上，则计算f值，如果这次的值比之前更小，那就：
    * 更新父辈节点
    * 如果j在CLOSED表中，则把它移回OPEN表中
* 转向步骤2

##### 有序搜索

宽度优先搜索、等代价搜素和深度优先搜索统统是有序搜索技术的特例。对于宽度优先有所，选择f(i)作为节点i的深度。对于等代价搜索，f(i)是从起始节点到节点i这段路径的代价。

由此可见，f(n) 的选择直接决定了这个算法的有效性。

##### 下面看几个选择评价函数 f(n) 的例子

##### 贪婪最佳优先搜索

评价函数f(n) = h(n)

光看这个名字，肯定是用了贪婪算法，可是哪里用到了贪婪算法呢

结合 f(n) 和 h(n)，大概明白了，每次选择节点进行拓展时都选取f(n)最小的节点进行拓展，猜对了就是这个思路。

![image-20230620094357531](C:\Users\hp   Ming\AppData\Roaming\Typora\typora-user-images\image-20230620094357531.png)

##### A* 算法

这个算法定义的评价函数不是只看节点与终点的代价距离，而是把起点到当前节点的距离也考虑在内。

于是引入 g(n) 表示从起始节点到节点n的开销带价值，h(n) 表示从n到目标节点的最小代价。

于是就有了 f(n) = g(n) + h(n)

![image-20230620094620827](C:\Users\hp   Ming\AppData\Roaming\Typora\typora-user-images\image-20230620094620827.png)

![image-20230620094632220](C:\Users\hp   Ming\AppData\Roaming\Typora\typora-user-images\image-20230620094632220.png)

这里其实可以看出来，上面的贪婪算法和这个算法的结果不一样，但是这个算法的结果是正确的，所以贪婪算法不一定给出最优解。

##### 对抗搜索

* 游戏的两个要素：MAX 和 MIN
* 站在玩家 MAX 的角度去搜索赢得策略
* MAX方的目标：尽可能使自己达到最大分数的行动方案，用 “或” 描述，称为 MAX 方节点
* MIN方的目标：尽可能是对方获得最小分数的行动方案，用 “与” 描述，是由MIN 方自主进行控制的，成为MIN节点

##### 博弈树

根据一方把上述双方逐层交替的博弈过程用与/或树 (图) 描述表达出来，即一颗具有 “与/或” 节点交替出现的博弈树

特点：

* 博弈的初始格局是初始节点
* 在博弈树中或节点和与节点逐层交替出现
* 把本方获胜的终局定义为本原问题，而所有使对方获胜的终局和属于对方最优搜索路径上的节点则是不可解节点

##### 极小极大分析法

在二人博弈中常用分析方法就是极小极大化搜索法。

主要思想：

* 设博弈的一方是MAX方，其目标是尽可能使自己得到最高分；另一方是MIN方，其目标是尽可能给MAX方送出最低分
* 考虑每一方案实施后对方可能采取的所有行动，并为其计算所有得分
* 计算节点得分，根据问题的特性定义一个估价函数，用来估算当前博弈树所有端节点的得分。此时估算出来的得分沉稳给静态估值
* 父辈节点的得分：当端节点的估值计算出来后，再推算父辈节点的得分，推算方法是：对 或 节点，选择其子节点中最大的得分作为父节点的得分，对 与 节点，选择其子结点中最小的得分作为父辈节点的得分
* 如果一个行动方案能获得较大的倒推值，则它就是当前最好的行动方案

来张图：

![image-20230620132632307](C:\Users\hp   Ming\AppData\Roaming\Typora\typora-user-images\image-20230620132632307.png)

博弈树极大极小分析的局限：

* 博弈树很庞大，所以很难搜索，很耗费时间，
* 所以一种方法就是剪枝技术

#### α - β剪枝技术

具体思想：边生成博弈树边估算个节点的倒推值，并且根据评估出的倒推值范围，及时停止拓展那些已无必要再拓展的子节点。通常都要使用某种深度优先搜索的方法。

具体剪枝方法：

* 对于一个 “与” 节点MIN，若能估计
* 剪枝通常采用深度优先搜索的策略进行

现在能知道为什么剪枝，但是不清楚 α 和 β 代表什么。。。

懂了！！！

看了B站up主的视频懂了，值得三连

总结一下：

* α 初始值为 -∞，β 初始值为 +∞
* MAX 节点只改变 α，α = max (α，β)，后面是回溯过来的子节点的 α 和 β
* MIN 节点只改变 β，β = min (α，β)，后面是回溯过来的子节点 α 和 β
* 当该节点的 α >= β 的时候，就不用扩展该节点剩余子节点了，直接剪枝。
* MAX 下面的剪枝是 β 剪枝，MIN 下面的剪枝是 α 剪枝

##### 蒙特卡洛树搜索

woc，太难了。。。先学其他部分，再来学这部分。